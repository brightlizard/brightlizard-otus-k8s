Дано
Сервис Order со своей БД
Сервис Storage со своей БД (компенсируемая транзакция)
Сервис Payment со своей БД (поворотная транзакция)
Сервис Delivery со своей БД (повторяемая транзакция)

Каждый сервис может горизонтально масштабироваться.
Там где требуется синхронизация изменений между экземплярами сервиса она происходит через БД.
Сервисы связаны брокером сообщений с возможностью хранения. Например Kafka. И обмениваются сообщениями через топики.
В пилотной реализации обмен происходит в рамках одного приложения и для упрощения Kafka заменена шиной данной Vert.x которая не гарантирует сохранность данных,
но при выделении каждого сервиса необходима Kafka для сохранности сообщений.


Сервис Order

Создание заказа через POST /orders
Создание заказа через POST /orders
Для поддержки идемпотентности происходит проверка по X-Request-Id. Если запрос есть в бд, по нему достается заказ и происходит перенаправление на результаты.
Если запроса нет в БД создается новый заказ со статусами CREATED и происходит перенаправление на страницу с результатами заказов
Далее асинхронно отрабатывает следующая транзакция:
Отправить сообщение в сервис Storage на бронирование товара.
Если отправка упешная, перевести заказ в статус SEND_REQ_TO_STORAGE_SUCCESS
Если отправка неуспешная, перевести заказ в статус SEND_REQ_TO_STORAGE_ERROR
Сервис заказа асинхронно слушает сообщения от сервиса Storage
Если пришло сообщение об ошибке резервировании товара(ов), то сервис меняет статус заказа на STORAGE_RESERVE_ERROR
Если пришло сообщение об успешном резервировании товара(ов), то сервис меняет статус заказа на STORAGE_RESERVE_SUCCESS
Суммирует сколько нужно списать денег
И отправляет сообщение в сервис Payment на проведение оплаты для указанного покупателя
Если отправка упешная, перевести заказ в статус SEND_REQ_TO_PAYMENT_SUCCESS
Если отправка неуспешная, перевести заказ в статус SEND_REQ_TO_PAYMENT_ERROR
Сервис заказа асинхронно слушает сообщения от сервиса Payment
Если пришло сообщение об ошибке оплаты, то сервис меняет статус заказа на PAYMENT_ERROR
И отправляет сообщение в сервис Storage на откат резирвирования товара(ов)
Если отправка упешная, перевести заказ в статус SEND_REQ_TO_STORAGE_ROLLBACK_SUCCESS
Если отправка неуспешная, перевести заказ в статус SEND_REQ_TO_STORAGE_ROLLBACK_ERROR (отправить повторно)
Если пришло успешное сообщение об оплате, то сервис меняет статус заказа на PAYMENT_SUCCESS
Отправляет запрос в сервис Delivery на формирование доставки
Если отправка упешная, перевести заказ в статус SEND_REQ_TO_DELIVERY_SUCCESS
Если отправка неуспешная, перевести заказ в статус SEND_REQ_TO_DELIVERY_ERROR

Отслеживание результатов запросов через GET /results
Запрос возвращает выборку заказов из БД по конкретному покупателю.


Сервис Storage
Слушает сообщения на резервирование от сервиса Order
Получив сообщение пытается зарезервировать товар
Если резервирование успешно, отправляет успешный ответ в сервис заказа
Если резервирование неуспешно, отправляет неуспешный ответ в сервис заказа
Слушает сообщения на откат резервирование от сервиса Order
Получив сообщение пытается откатить зарезервированный товар
Если откат успешен, ничего не делает
Если откат неуспешен, то пытается повторить N раз (тут возможны варианты, но не в рамках этого ДЗ, уже слишком объемно получается)

Сервис Payment
Слушает сообщения на оплату от сервиса Order
Получив сообщение на оплату проверяет/пробует списать деньги покупателя. Со счета, процессинг и т.д. Вне домашнего задания.
Если списание успешно, отправляет успешный ответ о списании в сервис заказов
Если списание неуспешно, отправляет неуспешный ответ о списании в сервис заказов

Сервис Delivery
Слушает сообщения на формирование доставки от сервиса Order
Получив сообщение на доставку каким-либо образом удостоверивает об этом доступного курьера
Если успешно, то клиент наверное получает товар
Если неуспешно, опять же, много вариантов вне ДЗ
